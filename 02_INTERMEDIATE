-- 서브쿼리 (Subquery)
-- 쿼리 안에 또 다른 쿼리를 넣어서, 비교나 조건에 사용할 수 있음
-- 예: 평균 매출보다 높은 직원 찾기

SELECT name, sales
FROM employees
WHERE sales > (
    SELECT AVG(sales)
    FROM employees
);

-- FROM절 안에 서브쿼리
-- 서브쿼리를 하나의 임시 테이블처럼 사용
SELECT dept, avg_sales
FROM (
    SELECT dept, AVG(sales) AS avg_sales
    FROM employees
    GROUP BY dept
) AS dept_avg
WHERE avg_sales >= 1000000;

-- SELECT절 안에 서브쿼리
-- 각 직원의 매출이 전체 평균보다 높은지 여부 표시
SELECT 
    name,
    sales,
    (SELECT AVG(sales) FROM employees) AS company_avg,
    CASE 
        WHEN sales > (SELECT AVG(sales) FROM employees) THEN 'Above Avg'
        ELSE 'Below Avg'
    END AS sales_level
FROM employees;

-- CTE (Common Table Expression)
-- WITH문을 사용해서 쿼리를 단계별로 나눠서 작성할 수 있음
-- 복잡한 서브쿼리를 보기 좋게 구조화하는 용도

-- 예: 월별 매출 요약 후 상위 부서 출력
WITH monthly_sales AS (
    SELECT 
        dept,
        SUM(sales) AS total_sales
    FROM sales_data
    WHERE month = '2024-10'
    GROUP BY dept
),
ranked_sales AS (
    SELECT
        dept,
        total_sales,
        RANK() OVER (ORDER BY total_sales DESC) AS sales_rank
    FROM monthly_sales
)
SELECT *
FROM ranked_sales
WHERE sales_rank <= 3;  -- 상위 3개 부서만 조회


-- 여러 단계 CTE 연결
WITH base_data AS (
    SELECT dept, SUM(sales) AS total_sales
    FROM sales_data
    GROUP BY dept
),
avg_data AS (
    SELECT AVG(total_sales) AS avg_sales
    FROM base_data
)
SELECT 
    b.dept,
    b.total_sales,
    CASE 
        WHEN b.total_sales >= (SELECT avg_sales FROM avg_data)
        THEN 'Above Avg'
        ELSE 'Below Avg'
    END AS performance
FROM base_data b;

-- 윈도우 함수 (Window Function)
-- 집계함수를 사용하되, 그룹으로 묶지 않고 행 단위로 결과를 보여줌

-- RANK() : 순위 매기기
SELECT 
    dept,
    employee,
    sales,
    RANK() OVER (PARTITION BY dept ORDER BY sales DESC) AS sales_rank
FROM sales_data;

-- DENSE_RANK() : 동일한 값이 있을 때 순위를 건너뛰지 않고 매김
-- 예를 들어 매출이 같은 직원이 여러 명일 때, 순위가 연속적으로 유지됨
SELECT 
    dept,
    employee,
    sales,
    DENSE_RANK() OVER (PARTITION BY dept ORDER BY sales DESC) AS dense_rank_in_dept
FROM sales_data
ORDER BY dept, dense_rank_in_dept;

-- SUM() OVER : 누적합 구하기
SELECT 
    employee,
    sales,
    SUM(sales) OVER (ORDER BY sales_date ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS cumulative_sales
FROM sales_data
WHERE dept = '서울지점';

-- 비율 계산 (전체 대비)
SELECT
    dept,
    employee,
    sales,
    ROUND(
        sales * 100.0 / SUM(sales) OVER (PARTITION BY dept),
        2
    ) AS dept_sales_ratio
FROM sales_data;

-- ROW_NUMBER() : 각 행에 일련번호 부여
SELECT 
    employee,
    dept,
    ROW_NUMBER() OVER (PARTITION BY dept ORDER BY hire_date ASC) AS join_order
FROM employees;
